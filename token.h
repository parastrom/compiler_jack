#ifndef TOKEN_H
#define TOKEN_H

#include <stdbool.h>
typedef enum {
    TOKEN_TYPE_UNRECOGNISED = 0, TOKEN_TYPE_ID, TOKEN_TYPE_NUM,
    TOKEN_TYPE_STRING, TOKEN_TYPE_CLASS, TOKEN_TYPE_CONSTRUCTOR,
    TOKEN_TYPE_METHOD, TOKEN_TYPE_FUNCTION, TOKEN_TYPE_INT,
    TOKEN_TYPE_BOOLEAN, TOKEN_TYPE_CHAR, TOKEN_TYPE_VOID,
    TOKEN_TYPE_VAR,TOKEN_TYPE_STATIC,TOKEN_TYPE_FIELD,
    TOKEN_TYPE_LET,TOKEN_TYPE_DO,TOKEN_TYPE_IF,
    TOKEN_TYPE_ELSE,TOKEN_TYPE_WHILE,TOKEN_TYPE_RETURN,
    TOKEN_TYPE_TRUE,TOKEN_TYPE_FALSE,TOKEN_TYPE_NULL,
    TOKEN_TYPE_THIS,TOKEN_TYPE_OPEN_PAREN,TOKEN_TYPE_CLOSE_PAREN,
    TOKEN_TYPE_OPEN_BRACE,TOKEN_TYPE_CLOSE_BRACE,TOKEN_TYPE_OPEN_BRACKET,
    TOKEN_TYPE_CLOSE_BRACKET,TOKEN_TYPE_COMMA,TOKEN_TYPE_SEMICOLON,
    TOKEN_TYPE_EQUAL,TOKEN_TYPE_PERIOD,TOKEN_TYPE_PLUS,
    TOKEN_TYPE_HYPHEN,TOKEN_TYPE_ASTERISK,TOKEN_TYPE_SLASH,
    TOKEN_TYPE_AMPERSAND,TOKEN_TYPE_BAR,TOKEN_TYPE_TILDE,
    TOKEN_TYPE_GREATER_THAN,TOKEN_TYPE_LESS_THAN,
    TOKEN_TYPE_LESS_THAN_EQUAL,      // '<='
    TOKEN_TYPE_GREATER_THAN_EQUAL,   // '>='
    TOKEN_TYPE_EQUAL_EQUAL,          // '=='
    TOKEN_TYPE_NOT_EQUAL,            // '!='
    TOKEN_TYPE_LOGICAL_AND,          // '&&'
    TOKEN_TYPE_LOGICAL_OR,           // '||'
    TOKEN_TYPE_INCREMENT,            // '++'
    TOKEN_TYPE_DECREMENT,            // '--'
    TOKEN_TYPE_PLUS_EQUAL,           // '+='
    TOKEN_TYPE_MINUS_EQUAL,          // '-='
    TOKEN_TYPE_MULTIPLY_EQUAL,       // '*='
    TOKEN_TYPE_DIVIDE_EQUAL,         // '/='
    TOKEN_TYPE_BITWISE_AND_EQUAL,    // '&='
    TOKEN_TYPE_BITWISE_OR_EQUAL,     // '|='
    TOKEN_TYPE_LEFT_SHIFT_EQUAL,     // '<<='
    TOKEN_TYPE_RIGHT_SHIFT_EQUAL,    // '>>='
} TokenType;

typedef enum {
    TOKEN_CATEGORY_UNRECOGNISED    = 0,
    TOKEN_CATEGORY_CLASS_VAR       = 1 << 0,
    TOKEN_CATEGORY_SUBROUTINE_DEC  = 1 << 1,
    TOKEN_CATEGORY_STATEMENT       = 1 << 2,
    TOKEN_CATEGORY_TYPE            = 1 << 3,
    TOKEN_CATEGORY_FACTOR          = 1 << 4,
    TOKEN_CATEGORY_UNARY           = 1 << 5,
    TOKEN_CATEGORY_RELATIONAL      = 1 << 6,
    TOKEN_CATEGORY_BOOLEAN         = 1 << 7,
    TOKEN_CATEGORY_ARITH      = 1 << 8
} TokenCategory;

typedef struct {
    TokenType type;
    char lx[128];
    int line;
} Token;

typedef struct {
    const char* str;
    TokenType tokenType;
} TokenMapping;

static const TokenMapping tokenMappings[21] = {
    {"class", TOKEN_TYPE_CLASS},
    {"constructor", TOKEN_TYPE_CONSTRUCTOR},
    {"method", TOKEN_TYPE_METHOD},
    {"function", TOKEN_TYPE_FUNCTION},
    {"int", TOKEN_TYPE_INT},
    {"boolean", TOKEN_TYPE_BOOLEAN},
    {"char", TOKEN_TYPE_CHAR},
    {"var", TOKEN_TYPE_VAR},
    {"void", TOKEN_TYPE_VOID},
    {"static", TOKEN_TYPE_STATIC},
    {"field", TOKEN_TYPE_FIELD},
    {"let", TOKEN_TYPE_LET},
    {"do", TOKEN_TYPE_DO},
    {"if", TOKEN_TYPE_IF},
    {"else", TOKEN_TYPE_ELSE},
    {"while", TOKEN_TYPE_WHILE},
    {"return", TOKEN_TYPE_RETURN},
    {"true", TOKEN_TYPE_TRUE},
    {"false", TOKEN_TYPE_FALSE},
    {"null", TOKEN_TYPE_NULL},
    {"this", TOKEN_TYPE_THIS},
    {"<=", TOKEN_TYPE_LESS_THAN_EQUAL},
    {">=", TOKEN_TYPE_GREATER_THAN_EQUAL},
    {"==", TOKEN_TYPE_EQUAL_EQUAL},
    {"!=", TOKEN_TYPE_NOT_EQUAL},
    {"&&", TOKEN_TYPE_LOGICAL_AND},
    {"||", TOKEN_TYPE_LOGICAL_OR},
    {"++", TOKEN_TYPE_INCREMENT},
    {"--", TOKEN_TYPE_DECREMENT},
    {"+=", TOKEN_TYPE_PLUS_EQUAL},
    {"-=", TOKEN_TYPE_MINUS_EQUAL},
    {"*=", TOKEN_TYPE_MULTIPLY_EQUAL},
    {"/=", TOKEN_TYPE_DIVIDE_EQUAL},
    {"&=", TOKEN_TYPE_BITWISE_AND_EQUAL},
    {"|=", TOKEN_TYPE_BITWISE_OR_EQUAL},
    {"<<=", TOKEN_TYPE_LEFT_SHIFT_EQUAL},
    {">>=", TOKEN_TYPE_RIGHT_SHIFT_EQUAL},
};

static const TokenCategory tokenCategories[62] = {
    [TOKEN_TYPE_ID] = TOKEN_CATEGORY_TYPE | TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_TILDE] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_UNARY,
    [TOKEN_TYPE_HYPHEN] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_UNARY | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_STATIC] = TOKEN_CATEGORY_CLASS_VAR,
    [TOKEN_TYPE_FIELD] = TOKEN_CATEGORY_CLASS_VAR,
    [TOKEN_TYPE_CONSTRUCTOR] = TOKEN_CATEGORY_SUBROUTINE_DEC,
    [TOKEN_TYPE_METHOD] = TOKEN_CATEGORY_SUBROUTINE_DEC,
    [TOKEN_TYPE_FUNCTION] = TOKEN_CATEGORY_SUBROUTINE_DEC,
    [TOKEN_TYPE_VAR] = TOKEN_CATEGORY_STATEMENT,
    [TOKEN_TYPE_LET] = TOKEN_CATEGORY_STATEMENT,
    [TOKEN_TYPE_IF] = TOKEN_CATEGORY_STATEMENT,
    [TOKEN_TYPE_WHILE] = TOKEN_CATEGORY_STATEMENT,
    [TOKEN_TYPE_DO] = TOKEN_CATEGORY_STATEMENT,
    [TOKEN_TYPE_RETURN] = TOKEN_CATEGORY_STATEMENT,
    [TOKEN_TYPE_INT] = TOKEN_CATEGORY_TYPE,
    [TOKEN_TYPE_CHAR] = TOKEN_CATEGORY_TYPE,
    [TOKEN_TYPE_BOOLEAN] = TOKEN_CATEGORY_TYPE,
    [TOKEN_TYPE_VOID] = TOKEN_CATEGORY_TYPE,
    [TOKEN_TYPE_NUM] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_OPEN_PAREN] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_OPEN_BRACKET] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_STRING] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_TRUE] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_FALSE] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_NULL] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_THIS] = TOKEN_CATEGORY_FACTOR,
    [TOKEN_TYPE_EQUAL] = TOKEN_CATEGORY_RELATIONAL,
    [TOKEN_TYPE_GREATER_THAN] = TOKEN_CATEGORY_RELATIONAL,
    [TOKEN_TYPE_LESS_THAN] = TOKEN_CATEGORY_RELATIONAL,
    [TOKEN_TYPE_NOT_EQUAL] = TOKEN_CATEGORY_RELATIONAL,
    [TOKEN_TYPE_LOGICAL_AND] = TOKEN_CATEGORY_BOOLEAN,
    [TOKEN_TYPE_LOGICAL_OR] = TOKEN_CATEGORY_BOOLEAN,
    [TOKEN_TYPE_INCREMENT] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_DECREMENT] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_PLUS_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_MINUS_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_MULTIPLY_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_DIVIDE_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_BITWISE_AND_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_BITWISE_OR_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_LEFT_SHIFT_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
    [TOKEN_TYPE_RIGHT_SHIFT_EQUAL] = TOKEN_CATEGORY_FACTOR | TOKEN_CATEGORY_ARITH,
};
static const TokenType charToTokenType[256] = {
    ['('] = TOKEN_TYPE_OPEN_PAREN,
    [')'] = TOKEN_TYPE_CLOSE_PAREN,
    ['{'] = TOKEN_TYPE_OPEN_BRACE,
    ['}'] = TOKEN_TYPE_CLOSE_BRACE,
    ['['] = TOKEN_TYPE_OPEN_BRACKET,
    [']'] = TOKEN_TYPE_CLOSE_BRACKET,
    [','] = TOKEN_TYPE_COMMA,
    [';'] = TOKEN_TYPE_SEMICOLON,
    ['='] = TOKEN_TYPE_EQUAL,
    ['.'] = TOKEN_TYPE_PERIOD,
    ['+'] = TOKEN_TYPE_PLUS,
    ['-'] = TOKEN_TYPE_HYPHEN,
    ['*'] = TOKEN_TYPE_ASTERISK,
    ['/'] = TOKEN_TYPE_SLASH,
    ['&'] = TOKEN_TYPE_AMPERSAND,
    ['|'] = TOKEN_TYPE_BAR,
    ['~'] = TOKEN_TYPE_TILDE,
    ['<'] = TOKEN_TYPE_LESS_THAN,
    ['>'] = TOKEN_TYPE_GREATER_THAN,
};


TokenType token_type_from_str(const char* str);
TokenType token_type_from_char(char ch);

TokenCategory get_token_category(TokenType type);
bool is_token_of_category(TokenType type, TokenCategory category);
bool is_token_category(TokenType type, TokenCategory category);
Token* new_token(TokenType type, const char* lx, int line);
void destroy_token(Token* token);
TokenType get_token_type(const Token* token);
char* get_token_lx(const Token* token);

void fmt(const Token* token);


#endif  // TOKEN_H